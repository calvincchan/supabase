create table "public"."page" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "created_by_name" text,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid,
    "updated_by_name" text,
    "title" text,
    "content" text
);


CREATE UNIQUE INDEX page_pkey ON public.page USING btree (id);

alter table "public"."page" add constraint "page_pkey" PRIMARY KEY using index "page_pkey";

alter table "public"."page" add constraint "page_created_by_fkey" FOREIGN KEY (created_by) REFERENCES team_member(id) not valid;

alter table "public"."page" validate constraint "page_created_by_fkey";

alter table "public"."page" add constraint "page_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES team_member(id) not valid;

alter table "public"."page" validate constraint "page_updated_by_fkey";

grant delete on table "public"."page" to "anon";

grant insert on table "public"."page" to "anon";

grant references on table "public"."page" to "anon";

grant select on table "public"."page" to "anon";

grant trigger on table "public"."page" to "anon";

grant truncate on table "public"."page" to "anon";

grant update on table "public"."page" to "anon";

grant delete on table "public"."page" to "authenticated";

grant insert on table "public"."page" to "authenticated";

grant references on table "public"."page" to "authenticated";

grant select on table "public"."page" to "authenticated";

grant trigger on table "public"."page" to "authenticated";

grant truncate on table "public"."page" to "authenticated";

grant update on table "public"."page" to "authenticated";

grant delete on table "public"."page" to "postgres";

grant insert on table "public"."page" to "postgres";

grant references on table "public"."page" to "postgres";

grant select on table "public"."page" to "postgres";

grant trigger on table "public"."page" to "postgres";

grant truncate on table "public"."page" to "postgres";

grant update on table "public"."page" to "postgres";

grant delete on table "public"."page" to "service_role";

grant insert on table "public"."page" to "service_role";

grant references on table "public"."page" to "service_role";

grant select on table "public"."page" to "service_role";

grant trigger on table "public"."page" to "service_role";

grant truncate on table "public"."page" to "service_role";

grant update on table "public"."page" to "service_role";

create policy "Enable delete for creator and managers"
on "public"."page"
as permissive
for delete
to authenticated
using (((auth.uid() = created_by) OR is_manager()));


create policy "Enable insert for all users"
on "public"."page"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for all users"
on "public"."page"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for creator or managers"
on "public"."page"
as permissive
for update
to authenticated
using (true)
with check (((auth.uid() = created_by) OR is_manager()));


CREATE TRIGGER audit_i_u_d AFTER INSERT OR DELETE OR UPDATE ON public.page FOR EACH ROW EXECUTE FUNCTION audit.insert_update_delete_trigger();

CREATE TRIGGER audit_t AFTER TRUNCATE ON public.page FOR EACH STATEMENT EXECUTE FUNCTION audit.truncate_trigger();

CREATE TRIGGER page_set_created_meta BEFORE INSERT ON public.page FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER page_set_updated_meta BEFORE INSERT OR UPDATE ON public.page FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

create view
  public.page_oplog as
select
  rv.id,
  rv.record_id,
  rv.old_record_id,
  rv.op,
  rv.ts,
  rv.record,
  rv.old_record,
  rv.auth_uid,
  rv.auth_role,
  tm.name as actor,
  rv.table_name
from
  audit.record_version rv
  left join team_member tm on rv.auth_uid = tm.id
where
  rv.table_oid = 'page'::regclass::oid;