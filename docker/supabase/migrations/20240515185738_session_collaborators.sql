--
-- Create a new table to store session-collaborator relationship
--
CREATE TABLE
  "public"."session_collaborator" (
    "session_id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    "user_id" UUID NOT NULL DEFAULT auth.uid (),
    "created_by" UUID NOT NULL DEFAULT auth.uid ()
  );

ALTER TABLE "public"."session_collaborator" OWNER TO "postgres";

ALTER TABLE "public"."session_collaborator" ENABLE ROW LEVEL SECURITY;

CREATE UNIQUE INDEX session_collaborator_pkey ON public.session_collaborator USING btree (session_id, user_id);

ALTER TABLE "public"."session_collaborator"
ADD CONSTRAINT "session_collaborator_pkey" PRIMARY KEY USING INDEX "session_collaborator_pkey";

ALTER TABLE "public"."session_collaborator"
ADD CONSTRAINT "public_session_collaborator_session_id_fkey" FOREIGN KEY (session_id) REFERENCES SESSION (id) ON DELETE CASCADE NOT VALID;

ALTER TABLE "public"."session_collaborator" VALIDATE CONSTRAINT "public_session_collaborator_session_id_fkey";

ALTER TABLE "public"."session_collaborator"
ADD CONSTRAINT "public_session_collaborator_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.team_member (id) ON DELETE CASCADE NOT VALID;

ALTER TABLE "public"."session_collaborator" VALIDATE CONSTRAINT "public_session_collaborator_user_id_fkey";

--
-- security policies
--
CREATE POLICY "Enable delete for creator and allowed roles" ON "public"."session_collaborator" FOR DELETE TO "authenticated" USING (
  (
    "public"."is_creator" ("created_by")
    OR "public"."is_allowed" ('session:delete'::"public"."permission_enum")
  )
);

CREATE POLICY "Enable insert for allowed roles" ON "public"."session_collaborator" FOR INSERT TO "authenticated"
WITH
  CHECK (
    "public"."is_allowed" ('session:create'::"public"."permission_enum")
  );

CREATE POLICY "Enable select for all users" ON "public"."session_collaborator" FOR
SELECT
  TO "authenticated" USING (TRUE);

CREATE POLICY "Enable update for creator and allowed roles" ON "public"."session_collaborator" FOR
UPDATE TO "authenticated" USING (TRUE)
WITH
  CHECK (
    (
      "public"."is_creator" ("created_by")
      OR "public"."is_allowed" ('session:edit'::"public"."permission_enum")
    )
  );

--
-- Create view to get sessions of the current user
--
CREATE OR REPLACE VIEW
  "public"."my_session" AS
SELECT
  "a"."id",
  "a"."case_id",
  "a"."created_at",
  "a"."created_by",
  "a"."created_by_name",
  "a"."updated_at",
  "a"."updated_by",
  "a"."updated_by_name",
  "a"."started_at",
  "a"."started_by",
  "a"."started_by_name",
  "a"."completed_at",
  "a"."completed_by",
  "a"."completed_by_name",
  "a"."content",
  "a"."language",
  "a"."status",
  "a"."collaborators",
  "a"."start_date",
  "a"."end_date",
  "a"."recurrence_rule",
  "a"."time_frame",
  "a"."time_frame_until",
  "a"."mode",
  "a"."learning",
  "a"."seb",
  "a"."counselling",
  "a"."cca",
  "a"."haoxue",
  "a"."non_case",
  "a"."parent_session",
  "a"."parent_session_note",
  "a"."recurrence_parent",
  "a"."recurrence_start_date"
FROM
  (
    "public"."session" "a"
    JOIN "public"."session_collaborator" "b" ON (("a"."id" = "b"."session_id"))
  )
WHERE
  ("b"."user_id" = "auth"."uid" ());

--
-- Trigger to add creator as collaborator when a session is created
--
CREATE
OR REPLACE FUNCTION public.insert_session_collaborator () RETURNS TRIGGER LANGUAGE plpgsql AS $function$
BEGIN
  INSERT INTO "public"."session_collaborator" ("session_id", "user_id")
  VALUES (NEW.id, NEW.created_by);
  RETURN NEW;
END;
$function$;

CREATE TRIGGER session_i
AFTER INSERT ON "public"."session" FOR EACH ROW
EXECUTE FUNCTION public.insert_session_collaborator ();

--
-- Function to get session collaborators by session ID
--
CREATE
OR REPLACE FUNCTION public.get_session_collaborator_details (p_session_id BIGINT) RETURNS TABLE (user_id UUID, session_id BIGINT, NAME TEXT) LANGUAGE plpgsql AS $function$
BEGIN
  RETURN QUERY
  SELECT a.user_id, a.session_id, b.name
  FROM session_collaborator AS a
  JOIN team_member AS b ON a.user_id = b.id
  WHERE a.session_id = p_session_id
  ORDER BY b.name;
END;
$function$;

--
-- Trigger to update "collaborators" field in session table when a collaborator is inserted, updated or deleted
--
CREATE
OR REPLACE FUNCTION public.trigger_set_session_collaborator () RETURNS TRIGGER LANGUAGE plpgsql AS $function$
DECLARE
  collaborator_string TEXT;
  p_session_id BIGINT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    p_session_id := OLD.session_id;
  ELSE
    p_session_id := NEW.session_id;
  END IF;

  SELECT STRING_AGG(b.name, '|' ORDER BY b.name ASC) INTO collaborator_string
  FROM session_collaborator AS a
  JOIN team_member AS b ON a.user_id = b.id
  WHERE a.session_id = p_session_id;

  UPDATE "session" SET collaborators = COALESCE(collaborator_string, '') WHERE id = p_session_id;

  RETURN NEW;
END;
$function$;

CREATE TRIGGER session_collaborator_i_u_d
AFTER INSERT
OR DELETE
OR
UPDATE ON public.session_collaborator FOR EACH ROW
EXECUTE FUNCTION trigger_set_session_collaborator ();

--
-- Run the function to update the "collaborators" field in the session table
--
DO $$
DECLARE
  session RECORD;
BEGIN
  FOR session IN SELECT * FROM "public"."session" LOOP
    PERFORM public.trigger_set_session_collaborator();
  END LOOP;
END $$;

--
-- Inital data: for each existing session, add the creator as a collaborator
--
DO $$
DECLARE
  session RECORD;
BEGIN
  FOR session IN SELECT * FROM "public"."session" LOOP
    INSERT INTO "public"."session_collaborator" ("session_id", "user_id", "created_at", "created_by")
    VALUES (session.id, session.created_by, session.created_at, session.created_by);
  END LOOP;
END $$;