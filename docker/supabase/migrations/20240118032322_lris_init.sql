create table "public"."case" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "student_name" text not null default ''::text,
    "student_no" text,
    "updated_at" timestamp with time zone,
    "updated_by" uuid,
    "is_archived" boolean,
    "archived_at" timestamp with time zone,
    "archived_by" uuid,
    "case_status" character(1) default 'I'::bpchar,
    "updated_by_name" text,
    "grade" character varying(10),
    "homeroom" character varying(100),
    "created_by" uuid,
    "created_by_name" text,
    "tier" character(1) default '1'::bpchar,
    "last_session_at" timestamp with time zone,
    "next_session_at" timestamp with time zone,
    "last_session_by" uuid,
    "last_session_by_name" text,
    "student_first_name" text not null default ''::text,
    "student_last_name" text not null default ''::text,
    "background" text,
    "student_other_name" text not null default ''::text,
    "gender" character(1),
    "dob" date,
    "email" text,
    "parent_email" text,
    "mother_name" text,
    "mother_phone" text,
    "mother_email" text,
    "father_name" text,
    "father_phone" text,
    "father_email" text,
    "handlers" text not null default ''::text
);


alter table "public"."case" enable row level security;

create table "public"."case_handler" (
    "case_id" bigint not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null,
    "is_main_handler" boolean not null default false,
    "created_by" uuid
);


alter table "public"."case_handler" enable row level security;

create table "public"."profile" (
    "case_id" bigint not null,
    "created_at" timestamp with time zone default now(),
    "date_of_birth" date,
    "chinese_name" text,
    "gender" character(1)
);


alter table "public"."profile" enable row level security;

create table "public"."progress_note" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid,
    "case_id" bigint,
    "content" text,
    "created_by_name" text,
    "updated_by_name" text,
    "tags" bpchar[]
);


alter table "public"."progress_note" enable row level security;

create table "public"."reminder" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid,
    "created_by_name" text,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid,
    "updated_by_name" text,
    "content" text,
    "due_date" timestamp with time zone,
    "is_completed" boolean not null default false,
    "completed_at" timestamp with time zone,
    "completed_by" uuid,
    "completed_by_name" text,
    "case_id" bigint
);


alter table "public"."reminder" enable row level security;

create table "public"."session" (
    "id" bigint generated by default as identity not null,
    "case_id" bigint,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid,
    "created_by_name" text,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid,
    "updated_by_name" text,
    "started_at" timestamp with time zone,
    "started_by" uuid,
    "started_by_name" text,
    "completed_at" timestamp with time zone,
    "completed_by" uuid,
    "completed_by_name" text,
    "content" text not null default ''::text,
    "language" character(1) not null default '''E'''::bpchar,
    "status" character(1) not null default 'U'::bpchar,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "recurrence_rule" text not null default ''::text,
    "time_frame" character(1) not null default ''::bpchar,
    "time_frame_until" timestamp with time zone,
    "mode" character(1) not null default ''::bpchar,
    "learning" character(1) not null default ''::bpchar,
    "seb" character(1) not null default ''::bpchar,
    "counselling" character(1) not null default ''::bpchar,
    "cca" character(1) not null default ''::bpchar,
    "haoxue" character(1) not null default ''::bpchar,
    "non_case" character(1) not null default ''::bpchar,
    "parent_session" character(1) not null default ''::bpchar,
    "parent_session_note" text,
    "recurrence_parent" bigint
);


alter table "public"."session" enable row level security;

create table "public"."target" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid,
    "created_by_name" text,
    "updated_at" timestamp with time zone,
    "updated_by" uuid,
    "updated_by_name" text,
    "targets" text[] not null default '{}'::text[]
);


alter table "public"."target" enable row level security;

create table "public"."team_member" (
    "id" uuid not null,
    "name" text not null,
    "role" character(1) default NULL::bpchar,
    "email" text,
    "last_sign_in_at" timestamp with time zone
);


alter table "public"."team_member" enable row level security;

CREATE UNIQUE INDEX case_handler_pkey ON public.case_handler USING btree (case_id, user_id);

CREATE UNIQUE INDEX case_pkey ON public."case" USING btree (id);

CREATE UNIQUE INDEX profile_pkey ON public.profile USING btree (case_id);

CREATE UNIQUE INDEX progress_note_pkey ON public.progress_note USING btree (id);

CREATE UNIQUE INDEX reminder_pkey ON public.reminder USING btree (id);

CREATE UNIQUE INDEX session_pkey ON public.session USING btree (id);

CREATE UNIQUE INDEX target_pkey ON public.target USING btree (id);

CREATE UNIQUE INDEX team_member_pkey ON public.team_member USING btree (id);

alter table "public"."case" add constraint "case_pkey" PRIMARY KEY using index "case_pkey";

alter table "public"."case_handler" add constraint "case_handler_pkey" PRIMARY KEY using index "case_handler_pkey";

alter table "public"."profile" add constraint "profile_pkey" PRIMARY KEY using index "profile_pkey";

alter table "public"."progress_note" add constraint "progress_note_pkey" PRIMARY KEY using index "progress_note_pkey";

alter table "public"."reminder" add constraint "reminder_pkey" PRIMARY KEY using index "reminder_pkey";

alter table "public"."session" add constraint "session_pkey" PRIMARY KEY using index "session_pkey";

alter table "public"."target" add constraint "target_pkey" PRIMARY KEY using index "target_pkey";

alter table "public"."team_member" add constraint "team_member_pkey" PRIMARY KEY using index "team_member_pkey";

alter table "public"."case" add constraint "case_case_status_check" CHECK ((case_status = ANY (ARRAY['I'::bpchar, 'C'::bpchar, 'N'::bpchar, 'A'::bpchar, 'R'::bpchar, 'X'::bpchar]))) not valid;

alter table "public"."case" validate constraint "case_case_status_check";

alter table "public"."case" add constraint "case_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."case" validate constraint "case_created_by_fkey";

alter table "public"."case" add constraint "case_last_session_by_fkey" FOREIGN KEY (last_session_by) REFERENCES auth.users(id) not valid;

alter table "public"."case" validate constraint "case_last_session_by_fkey";

alter table "public"."case" add constraint "case_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."case" validate constraint "case_updated_by_fkey";

alter table "public"."case_handler" add constraint "case_handler_case_id_fkey" FOREIGN KEY (case_id) REFERENCES "case"(id) ON DELETE CASCADE not valid;

alter table "public"."case_handler" validate constraint "case_handler_case_id_fkey";

alter table "public"."case_handler" add constraint "case_handler_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."case_handler" validate constraint "case_handler_created_by_fkey";

alter table "public"."case_handler" add constraint "case_handler_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."case_handler" validate constraint "case_handler_user_id_fkey";

alter table "public"."profile" add constraint "profile_case_id_fkey" FOREIGN KEY (case_id) REFERENCES "case"(id) ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_case_id_fkey";

alter table "public"."profile" add constraint "profile_gender_check" CHECK ((gender = ANY (ARRAY['M'::bpchar, 'F'::bpchar, 'U'::bpchar]))) not valid;

alter table "public"."profile" validate constraint "profile_gender_check";

alter table "public"."progress_note" add constraint "progress_note_case_id_fkey" FOREIGN KEY (case_id) REFERENCES "case"(id) ON DELETE CASCADE not valid;

alter table "public"."progress_note" validate constraint "progress_note_case_id_fkey";

alter table "public"."progress_note" add constraint "progress_note_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."progress_note" validate constraint "progress_note_created_by_fkey";

alter table "public"."progress_note" add constraint "progress_note_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."progress_note" validate constraint "progress_note_updated_by_fkey";

alter table "public"."reminder" add constraint "reminder_case_id_fkey" FOREIGN KEY (case_id) REFERENCES "case"(id) not valid;

alter table "public"."reminder" validate constraint "reminder_case_id_fkey";

alter table "public"."reminder" add constraint "reminder_completed_by_fkey" FOREIGN KEY (completed_by) REFERENCES auth.users(id) not valid;

alter table "public"."reminder" validate constraint "reminder_completed_by_fkey";

alter table "public"."reminder" add constraint "reminder_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."reminder" validate constraint "reminder_created_by_fkey";

alter table "public"."reminder" add constraint "reminder_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."reminder" validate constraint "reminder_updated_by_fkey";

alter table "public"."session" add constraint "session_case_id_fkey" FOREIGN KEY (case_id) REFERENCES "case"(id) not valid;

alter table "public"."session" validate constraint "session_case_id_fkey";

alter table "public"."session" add constraint "session_completed_by_fkey" FOREIGN KEY (completed_by) REFERENCES auth.users(id) not valid;

alter table "public"."session" validate constraint "session_completed_by_fkey";

alter table "public"."session" add constraint "session_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."session" validate constraint "session_created_by_fkey";

alter table "public"."session" add constraint "session_recurrence_parent_fkey" FOREIGN KEY (recurrence_parent) REFERENCES session(id) not valid;

alter table "public"."session" validate constraint "session_recurrence_parent_fkey";

alter table "public"."session" add constraint "session_started_by_fkey" FOREIGN KEY (started_by) REFERENCES auth.users(id) not valid;

alter table "public"."session" validate constraint "session_started_by_fkey";

alter table "public"."session" add constraint "session_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."session" validate constraint "session_updated_by_fkey";

alter table "public"."target" add constraint "target_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."target" validate constraint "target_created_by_fkey";

alter table "public"."target" add constraint "target_id_fkey" FOREIGN KEY (id) REFERENCES "case"(id) ON DELETE CASCADE not valid;

alter table "public"."target" validate constraint "target_id_fkey";

alter table "public"."target" add constraint "target_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."target" validate constraint "target_updated_by_fkey";

alter table "public"."team_member" add constraint "team_member_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."team_member" validate constraint "team_member_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.find_next_upcoming_session(p_case_id bigint)
 RETURNS timestamp with time zone
 LANGUAGE plpgsql
AS $function$
DECLARE
  closest_start_date TIMESTAMP WITH TIME ZONE;
BEGIN
  SELECT start_date INTO closest_start_date
  FROM session
  WHERE case_id = p_case_id AND status = 'U' AND start_date >= CURRENT_DATE
  ORDER BY start_date ASC
  LIMIT 1;

  RETURN closest_start_date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_case_handler_details(p_case_id bigint)
 RETURNS TABLE(user_id uuid, case_id bigint, name text, is_main_handler boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT a.user_id, a.case_id, b.name, a.is_main_handler
  FROM case_handler AS a
  JOIN team_member AS b ON a.user_id = b.id
  WHERE a.case_id = p_case_id
  ORDER BY b.name;END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_cases_by_handler(p_user_id uuid)
 RETURNS TABLE(id bigint, student_name text, student_no text, next_session_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT a.id, a.student_name, a.student_no, a.next_session_at
  FROM "case" AS a
  JOIN "case_handler" AS b ON a.id = b.case_id
  WHERE b.user_id = p_user_id
  ORDER BY a.next_session_at;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_name()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_name TEXT;
BEGIN
  SELECT name INTO v_name FROM team_member WHERE id = auth.uid();
  RETURN v_name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_role()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_role CHAR(1);
BEGIN
  SELECT role INTO v_role FROM team_member WHERE auth.uid() = p_user_id;
  RETURN v_role;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_into_target()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO "target" ("id")
    VALUES (NEW."id");
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.team_member (id, email, name, role)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'role');
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_case_handler(p_case_id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (
    SELECT EXISTS(
      SELECT 1 FROM case_handler WHERE case_id = p_case_id AND user_id = auth.uid()
    )
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_creator()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN created_by = auth.uid();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_manager()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (
    SELECT EXISTS(
      SELECT 1 FROM team_member WHERE id = auth.uid() AND role = 'A'
    )
  );
END;
$function$
;

create or replace view "public"."my_case" as  SELECT a.id,
    a.created_at,
    a.student_name,
    a.student_no,
    a.updated_at,
    a.updated_by,
    a.is_archived,
    a.archived_at,
    a.archived_by,
    a.case_status,
    a.updated_by_name,
    a.grade,
    a.homeroom,
    a.created_by,
    a.created_by_name,
    a.tier,
    a.last_session_at,
    a.next_session_at,
    a.last_session_by,
    a.last_session_by_name,
    a.handlers,
    a.student_first_name,
    a.student_last_name,
    a.background,
    a.student_other_name
   FROM ("case" a
     JOIN case_handler b ON ((a.id = b.case_id)))
  WHERE (b.user_id = auth.uid());


CREATE OR REPLACE FUNCTION public.set_completed_meta()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.is_completed = TRUE THEN
    NEW.completed_at := now();
    NEW.completed_by := auth.uid();
    SELECT get_name() INTO NEW.completed_by_name;
  ELSE
    NEW.completed_at := null;
    NEW.completed_by := null;
    NEW.completed_by_name := null;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_main_handler(p_case_id bigint, p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Set all rows with the given p_case_id to is_main_handler = false
  UPDATE case_handler
  SET is_main_handler = false
  WHERE case_id = p_case_id;

  -- Set the row with the given p_case_id and p_user_id to is_main_handler = true
  UPDATE case_handler
  SET is_main_handler = true
  WHERE case_id = p_case_id AND user_id = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_on_session_status()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF OLD.status = 'U' AND NEW.status = 'I' THEN
    UPDATE "case" SET last_session_at = NOW(), last_session_by = auth.uid(), last_session_by_name = get_name() WHERE id = NEW.case_id;
    NEW.started_at = NOW();
    NEW.started_by = auth.uid();
    SELECT get_name() INTO NEW.started_by_name;
  END IF;
  IF OLD.status = 'I' AND NEW.status = 'X' THEN
    UPDATE "case" SET last_session_at = NOW(), last_session_by = auth.uid(), last_session_by_name = get_name() WHERE id = NEW.case_id;
    NEW.completed_at = NOW();
    NEW.completed_by = auth.uid();
    SELECT get_name() INTO NEW.completed_by_name;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_set_created_meta()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.created_by := auth.uid();
  SELECT get_name() INTO NEW.created_by_name;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_set_handlers()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  handlers_string TEXT;
  p_case_id BIGINT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    p_case_id := OLD.case_id;
  ELSE
    p_case_id := NEW.case_id;
  END IF;

  SELECT STRING_AGG(b.name, '|' ORDER BY a.is_main_handler DESC, b.name ASC) INTO handlers_string
  FROM case_handler AS a
  JOIN team_member AS b ON a.user_id = b.id
  WHERE a.case_id = p_case_id;

  UPDATE "case" SET handlers = COALESCE(handlers_string, '') WHERE id = p_case_id;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_set_main_handler()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  main_handler_exists BOOLEAN;
BEGIN
  -- Check if there is another row with the same case_id and is_main_handler = true
  SELECT EXISTS (
    SELECT 1
    FROM case_handler
    WHERE case_id = NEW.case_id AND is_main_handler = true
  ) INTO main_handler_exists;

  -- If no other row with is_main_handler = true exists, set the current row's is_main_handler to true
  IF NOT main_handler_exists THEN
    NEW.is_main_handler := true;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_set_next_upcoming_session()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  p_case_id BIGINT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    p_case_id := OLD.case_id;
  ELSE
    p_case_id := NEW.case_id;
  END IF;

  UPDATE "case" SET next_session_at = find_next_upcoming_session(p_case_id) WHERE id = p_case_id;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_set_updated_meta()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at := now();
  NEW.updated_by := auth.uid();
  SELECT get_name() INTO NEW.updated_by_name;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        NEW."student_name" = TRIM(BOTH ' ' FROM UPPER(NEW."student_last_name") || ' ' || NEW."student_first_name");
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE public.team_member
  SET email = NEW.email,
      name = NEW.raw_user_meta_data->>'name',
      role = NEW.raw_user_meta_data->>'role'
  WHERE id = NEW.id;

  RETURN NEW;
END;
$function$
;

grant delete on table "public"."case" to "anon";

grant insert on table "public"."case" to "anon";

grant references on table "public"."case" to "anon";

grant select on table "public"."case" to "anon";

grant trigger on table "public"."case" to "anon";

grant truncate on table "public"."case" to "anon";

grant update on table "public"."case" to "anon";

grant delete on table "public"."case" to "authenticated";

grant insert on table "public"."case" to "authenticated";

grant references on table "public"."case" to "authenticated";

grant select on table "public"."case" to "authenticated";

grant trigger on table "public"."case" to "authenticated";

grant truncate on table "public"."case" to "authenticated";

grant update on table "public"."case" to "authenticated";

grant delete on table "public"."case" to "postgres";

grant insert on table "public"."case" to "postgres";

grant references on table "public"."case" to "postgres";

grant select on table "public"."case" to "postgres";

grant trigger on table "public"."case" to "postgres";

grant truncate on table "public"."case" to "postgres";

grant update on table "public"."case" to "postgres";

grant delete on table "public"."case" to "service_role";

grant insert on table "public"."case" to "service_role";

grant references on table "public"."case" to "service_role";

grant select on table "public"."case" to "service_role";

grant trigger on table "public"."case" to "service_role";

grant truncate on table "public"."case" to "service_role";

grant update on table "public"."case" to "service_role";

grant delete on table "public"."case_handler" to "anon";

grant insert on table "public"."case_handler" to "anon";

grant references on table "public"."case_handler" to "anon";

grant select on table "public"."case_handler" to "anon";

grant trigger on table "public"."case_handler" to "anon";

grant truncate on table "public"."case_handler" to "anon";

grant update on table "public"."case_handler" to "anon";

grant delete on table "public"."case_handler" to "authenticated";

grant insert on table "public"."case_handler" to "authenticated";

grant references on table "public"."case_handler" to "authenticated";

grant select on table "public"."case_handler" to "authenticated";

grant trigger on table "public"."case_handler" to "authenticated";

grant truncate on table "public"."case_handler" to "authenticated";

grant update on table "public"."case_handler" to "authenticated";

grant delete on table "public"."case_handler" to "postgres";

grant insert on table "public"."case_handler" to "postgres";

grant references on table "public"."case_handler" to "postgres";

grant select on table "public"."case_handler" to "postgres";

grant trigger on table "public"."case_handler" to "postgres";

grant truncate on table "public"."case_handler" to "postgres";

grant update on table "public"."case_handler" to "postgres";

grant delete on table "public"."case_handler" to "service_role";

grant insert on table "public"."case_handler" to "service_role";

grant references on table "public"."case_handler" to "service_role";

grant select on table "public"."case_handler" to "service_role";

grant trigger on table "public"."case_handler" to "service_role";

grant truncate on table "public"."case_handler" to "service_role";

grant update on table "public"."case_handler" to "service_role";

grant delete on table "public"."profile" to "anon";

grant insert on table "public"."profile" to "anon";

grant references on table "public"."profile" to "anon";

grant select on table "public"."profile" to "anon";

grant trigger on table "public"."profile" to "anon";

grant truncate on table "public"."profile" to "anon";

grant update on table "public"."profile" to "anon";

grant delete on table "public"."profile" to "authenticated";

grant insert on table "public"."profile" to "authenticated";

grant references on table "public"."profile" to "authenticated";

grant select on table "public"."profile" to "authenticated";

grant trigger on table "public"."profile" to "authenticated";

grant truncate on table "public"."profile" to "authenticated";

grant update on table "public"."profile" to "authenticated";

grant delete on table "public"."profile" to "postgres";

grant insert on table "public"."profile" to "postgres";

grant references on table "public"."profile" to "postgres";

grant select on table "public"."profile" to "postgres";

grant trigger on table "public"."profile" to "postgres";

grant truncate on table "public"."profile" to "postgres";

grant update on table "public"."profile" to "postgres";

grant delete on table "public"."profile" to "service_role";

grant insert on table "public"."profile" to "service_role";

grant references on table "public"."profile" to "service_role";

grant select on table "public"."profile" to "service_role";

grant trigger on table "public"."profile" to "service_role";

grant truncate on table "public"."profile" to "service_role";

grant update on table "public"."profile" to "service_role";

grant delete on table "public"."progress_note" to "anon";

grant insert on table "public"."progress_note" to "anon";

grant references on table "public"."progress_note" to "anon";

grant select on table "public"."progress_note" to "anon";

grant trigger on table "public"."progress_note" to "anon";

grant truncate on table "public"."progress_note" to "anon";

grant update on table "public"."progress_note" to "anon";

grant delete on table "public"."progress_note" to "authenticated";

grant insert on table "public"."progress_note" to "authenticated";

grant references on table "public"."progress_note" to "authenticated";

grant select on table "public"."progress_note" to "authenticated";

grant trigger on table "public"."progress_note" to "authenticated";

grant truncate on table "public"."progress_note" to "authenticated";

grant update on table "public"."progress_note" to "authenticated";

grant delete on table "public"."progress_note" to "postgres";

grant insert on table "public"."progress_note" to "postgres";

grant references on table "public"."progress_note" to "postgres";

grant select on table "public"."progress_note" to "postgres";

grant trigger on table "public"."progress_note" to "postgres";

grant truncate on table "public"."progress_note" to "postgres";

grant update on table "public"."progress_note" to "postgres";

grant delete on table "public"."progress_note" to "service_role";

grant insert on table "public"."progress_note" to "service_role";

grant references on table "public"."progress_note" to "service_role";

grant select on table "public"."progress_note" to "service_role";

grant trigger on table "public"."progress_note" to "service_role";

grant truncate on table "public"."progress_note" to "service_role";

grant update on table "public"."progress_note" to "service_role";

grant delete on table "public"."reminder" to "anon";

grant insert on table "public"."reminder" to "anon";

grant references on table "public"."reminder" to "anon";

grant select on table "public"."reminder" to "anon";

grant trigger on table "public"."reminder" to "anon";

grant truncate on table "public"."reminder" to "anon";

grant update on table "public"."reminder" to "anon";

grant delete on table "public"."reminder" to "authenticated";

grant insert on table "public"."reminder" to "authenticated";

grant references on table "public"."reminder" to "authenticated";

grant select on table "public"."reminder" to "authenticated";

grant trigger on table "public"."reminder" to "authenticated";

grant truncate on table "public"."reminder" to "authenticated";

grant update on table "public"."reminder" to "authenticated";

grant delete on table "public"."reminder" to "postgres";

grant insert on table "public"."reminder" to "postgres";

grant references on table "public"."reminder" to "postgres";

grant select on table "public"."reminder" to "postgres";

grant trigger on table "public"."reminder" to "postgres";

grant truncate on table "public"."reminder" to "postgres";

grant update on table "public"."reminder" to "postgres";

grant delete on table "public"."reminder" to "service_role";

grant insert on table "public"."reminder" to "service_role";

grant references on table "public"."reminder" to "service_role";

grant select on table "public"."reminder" to "service_role";

grant trigger on table "public"."reminder" to "service_role";

grant truncate on table "public"."reminder" to "service_role";

grant update on table "public"."reminder" to "service_role";

grant delete on table "public"."session" to "anon";

grant insert on table "public"."session" to "anon";

grant references on table "public"."session" to "anon";

grant select on table "public"."session" to "anon";

grant trigger on table "public"."session" to "anon";

grant truncate on table "public"."session" to "anon";

grant update on table "public"."session" to "anon";

grant delete on table "public"."session" to "authenticated";

grant insert on table "public"."session" to "authenticated";

grant references on table "public"."session" to "authenticated";

grant select on table "public"."session" to "authenticated";

grant trigger on table "public"."session" to "authenticated";

grant truncate on table "public"."session" to "authenticated";

grant update on table "public"."session" to "authenticated";

grant delete on table "public"."session" to "postgres";

grant insert on table "public"."session" to "postgres";

grant references on table "public"."session" to "postgres";

grant select on table "public"."session" to "postgres";

grant trigger on table "public"."session" to "postgres";

grant truncate on table "public"."session" to "postgres";

grant update on table "public"."session" to "postgres";

grant delete on table "public"."session" to "service_role";

grant insert on table "public"."session" to "service_role";

grant references on table "public"."session" to "service_role";

grant select on table "public"."session" to "service_role";

grant trigger on table "public"."session" to "service_role";

grant truncate on table "public"."session" to "service_role";

grant update on table "public"."session" to "service_role";

grant delete on table "public"."target" to "anon";

grant insert on table "public"."target" to "anon";

grant references on table "public"."target" to "anon";

grant select on table "public"."target" to "anon";

grant trigger on table "public"."target" to "anon";

grant truncate on table "public"."target" to "anon";

grant update on table "public"."target" to "anon";

grant delete on table "public"."target" to "authenticated";

grant insert on table "public"."target" to "authenticated";

grant references on table "public"."target" to "authenticated";

grant select on table "public"."target" to "authenticated";

grant trigger on table "public"."target" to "authenticated";

grant truncate on table "public"."target" to "authenticated";

grant update on table "public"."target" to "authenticated";

grant delete on table "public"."target" to "postgres";

grant insert on table "public"."target" to "postgres";

grant references on table "public"."target" to "postgres";

grant select on table "public"."target" to "postgres";

grant trigger on table "public"."target" to "postgres";

grant truncate on table "public"."target" to "postgres";

grant update on table "public"."target" to "postgres";

grant delete on table "public"."target" to "service_role";

grant insert on table "public"."target" to "service_role";

grant references on table "public"."target" to "service_role";

grant select on table "public"."target" to "service_role";

grant trigger on table "public"."target" to "service_role";

grant truncate on table "public"."target" to "service_role";

grant update on table "public"."target" to "service_role";

grant delete on table "public"."team_member" to "anon";

grant insert on table "public"."team_member" to "anon";

grant references on table "public"."team_member" to "anon";

grant select on table "public"."team_member" to "anon";

grant trigger on table "public"."team_member" to "anon";

grant truncate on table "public"."team_member" to "anon";

grant update on table "public"."team_member" to "anon";

grant delete on table "public"."team_member" to "authenticated";

grant insert on table "public"."team_member" to "authenticated";

grant references on table "public"."team_member" to "authenticated";

grant select on table "public"."team_member" to "authenticated";

grant trigger on table "public"."team_member" to "authenticated";

grant truncate on table "public"."team_member" to "authenticated";

grant update on table "public"."team_member" to "authenticated";

grant delete on table "public"."team_member" to "postgres";

grant insert on table "public"."team_member" to "postgres";

grant references on table "public"."team_member" to "postgres";

grant select on table "public"."team_member" to "postgres";

grant trigger on table "public"."team_member" to "postgres";

grant truncate on table "public"."team_member" to "postgres";

grant update on table "public"."team_member" to "postgres";

grant delete on table "public"."team_member" to "service_role";

grant insert on table "public"."team_member" to "service_role";

grant references on table "public"."team_member" to "service_role";

grant select on table "public"."team_member" to "service_role";

grant trigger on table "public"."team_member" to "service_role";

grant truncate on table "public"."team_member" to "service_role";

grant update on table "public"."team_member" to "service_role";

create policy "Disable delete"
on "public"."case"
as permissive
for delete
to public
using (false);


create policy "Enable insert for all users"
on "public"."case"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for all users"
on "public"."case"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for creator and managers"
on "public"."case"
as permissive
for update
to authenticated
using (true)
with check (((auth.uid() = created_by) OR is_manager()));


create policy "Enable read access for all users"
on "public"."case_handler"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable all operations for all users"
on "public"."profile"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable delete for creator and managers"
on "public"."progress_note"
as permissive
for delete
to authenticated
using (((auth.uid() = created_by) OR is_manager()));


create policy "Enable insert for all users"
on "public"."progress_note"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for all users"
on "public"."progress_note"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for creator or managers"
on "public"."progress_note"
as permissive
for update
to authenticated
using (true)
with check (((auth.uid() = created_by) OR is_manager()));


create policy "Enable delete for creator and managers"
on "public"."reminder"
as permissive
for delete
to authenticated
using (((auth.uid() = created_by) OR is_manager()));


create policy "Enable insert for all users"
on "public"."reminder"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for all users"
on "public"."reminder"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for creator or managers"
on "public"."reminder"
as permissive
for update
to authenticated
using (true)
with check (((auth.uid() = created_by) OR is_manager()));


create policy "Enable delete for creator and managers"
on "public"."session"
as permissive
for delete
to authenticated
using (((auth.uid() = created_by) OR is_manager()));


create policy "Enable insert for all users"
on "public"."session"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for all users"
on "public"."session"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for creator or managers"
on "public"."session"
as permissive
for update
to public
using (true)
with check (((auth.uid() = created_by) OR is_manager()));


create policy "Enable all operations for authenticated users"
on "public"."target"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable insert for service_role"
on "public"."team_member"
as permissive
for insert
to service_role
with check (true);


create policy "Enable read for authenticated users"
on "public"."team_member"
as permissive
for select
to authenticated, anon, service_role
using (true);


create policy "Enable update for authenticated manager"
on "public"."team_member"
as permissive
for update
to authenticated
using (true)
with check ((is_manager() OR (auth.uid() = id)));


CREATE TRIGGER case_set_created_meta BEFORE INSERT ON public."case" FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER case_set_updated_meta BEFORE INSERT OR UPDATE ON public."case" FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

CREATE TRIGGER insert_target AFTER INSERT ON public."case" FOR EACH ROW EXECUTE FUNCTION insert_into_target();

CREATE TRIGGER update_student_name_trigger BEFORE INSERT OR UPDATE ON public."case" FOR EACH ROW EXECUTE FUNCTION update_student_name();

CREATE TRIGGER set_handlers_after_delete AFTER DELETE ON public.case_handler FOR EACH ROW EXECUTE FUNCTION trigger_set_handlers();

CREATE TRIGGER set_handlers_after_insert AFTER INSERT ON public.case_handler FOR EACH ROW EXECUTE FUNCTION trigger_set_handlers();

CREATE TRIGGER set_handlers_after_update AFTER UPDATE ON public.case_handler FOR EACH ROW EXECUTE FUNCTION trigger_set_handlers();

CREATE TRIGGER set_main_handler_before_insert BEFORE INSERT ON public.case_handler FOR EACH ROW EXECUTE FUNCTION trigger_set_main_handler();

CREATE TRIGGER progress_note_set_created_meta BEFORE INSERT ON public.progress_note FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER progress_note_set_updated_meta BEFORE INSERT OR UPDATE ON public.progress_note FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

CREATE TRIGGER reminder_set_created_meta BEFORE INSERT ON public.reminder FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER reminder_set_updated_meta BEFORE INSERT OR UPDATE ON public.reminder FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

CREATE TRIGGER update_reminder_is_completed BEFORE UPDATE ON public.reminder FOR EACH ROW EXECUTE FUNCTION set_completed_meta();

CREATE TRIGGER session_set_created_meta BEFORE INSERT ON public.session FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER session_set_updated_meta BEFORE INSERT OR UPDATE ON public.session FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

CREATE TRIGGER trigger_on_session_status BEFORE UPDATE ON public.session FOR EACH ROW EXECUTE FUNCTION trigger_on_session_status();

CREATE TRIGGER trigger_set_next_upcoming_session AFTER INSERT OR DELETE OR UPDATE ON public.session FOR EACH ROW EXECUTE FUNCTION trigger_set_next_upcoming_session();

CREATE TRIGGER target_set_created_neta_on_create BEFORE INSERT ON public.target FOR EACH ROW EXECUTE FUNCTION trigger_set_created_meta();

CREATE TRIGGER target_set_updated_meta_on_create BEFORE INSERT ON public.target FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();

CREATE TRIGGER target_set_updated_meta_on_update BEFORE UPDATE ON public.target FOR EACH ROW EXECUTE FUNCTION trigger_set_updated_meta();


